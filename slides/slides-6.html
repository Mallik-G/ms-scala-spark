<!DOCTYPE html>
<html lang="en">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" />
<meta content="Asciidoctor 1.5.2" name="generator" />
<title>Tuning and Partitioning</title>
<link href="deck.js/themes/style/font.css" rel="stylesheet" />
<style>
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 1.2em; height: 1.2em; font-size: 0.9em; font-weight: bold; line-height: 1.2; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -0.1em; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.colist table td:first-of-type { padding-right: 0.25em; }
</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{font-weight: normal}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#00}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<link href="deck.js/core/deck.core.css" rel="stylesheet" />
<link href="deck.js/extensions/scale/deck.scale.css" media="screen" rel="stylesheet" />
<link href="deck.js/themes/style/datastax.css" media="screen" rel="stylesheet" />
<link href="deck.js/themes/transition/fade.css" media="screen" rel="stylesheet" />
<link href="deck.js/core/print.css" media="print" rel="stylesheet" />
<script src="deck.js/modernizr.custom.js"></script>
</head>
<body class="article">
<div class="deck-container">
<section class="slide" id="title-slide">
<h1>Tuning and Partitioning</h1>
</section>
<section class="slide" id="spark-tuning-partitioning-understanding-partitioning">
<h2>An RDD is a Distributed Collection of Partitions</h2>
<div class="ulist">
<ul>
<li>Spark automatically partitions RDDs</li>
<li>Spark automatically distributes partitions among nodes</li>
</ul>
</div>
<div class="imageblock center">
<div class="content">
<img alt="partitions" src="images/spark/tuning-partitioning/understanding-partitioning/partitions.svg" />
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>In this presentation, we will overview basics of Spark partitioning. Some details
will be omitted here for brevity but will be covered in subsequent presentations
when the time is right.</p></div>
</div>
</div>
</section>
<section class="slide" id="rdd-partitioning-properties">
<h2>RDD Partitioning Properties</h2>
<div class="paragraph"><p><strong>Number of partitions</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:20%" />
<col style="width:80%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns an <em>Array</em> with all partition references for the source RDD.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions.size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a number of partitions in the source RDD.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph"><p><br /></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>val movies = sc.parallelize(List(("Alice in Wonderland",2016), ("Alice Through the Looking Glass",2010), ...))
println(movies.partitions.size)
// Sample output: 3

val interactions = sc.cassandraTable("killr_video","video_interactions_by_user")
println(interactions.partitions.size)
// Sample output: 4</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>To find how many partitions an RDD contains, you can access RDD&#8217;s property <em>partitions</em> and get its <em>size</em>.</p></div>
<div class="paragraph"><p>In this example, we output a number of partitions for two sample RDDs: <em>movies</em> (created by parallelizing a collection)
and <em>interactions</em> (created from  a Cassandra table). Notice that this code does not use any actions and
therefore actual partitions with data are never computed. Nevertheless, Spark has a plan on how to compute such partitions
and how many of them.</p></div>
<div class="paragraph"><p>The content of the <em>partitions</em> array encodes references to partitions and is unlikely to be useful for developing
Spark applications.
An element of the <em>partitions</em> array may look similar to
<em>org.apache.spark.rdd.ParallelCollectionPartition@735</em> or
<em>CassandraPartition(0,Set(/172.31.26.129),Vector(CqlTokenRange(token("user_id") &#8656; ?,WrappedArray(-3074457345618258603))),127)</em>.</p></div>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>Partitioner</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:20%" />
<col style="width:80%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitioner</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns an <em>Option</em>[<em>Partitioner</em>] for the source RDD, where <em>Partitioner</em>, if any, can refer to
<em>HashPartitioner</em>, <em>RangePartitioner</em>, or a custom partitioner.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph"><p><br /></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>val movies = sc.parallelize(List(("Alice in Wonderland",2016), ("Alice Through the Looking Glass",2010), ...))
println(movies.partitioner)
// Sample output: None

val moviesByYear = movies.map{case (t,y) =&gt; (y,t)}.groupByKey
println(moviesByYear.partitioner)
// Sample output: Some(org.apache.spark.HashPartitioner@3)</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>RDD&#8217;s <em>partitioner</em> property can give you an idea about a strategy that is used to create RDD partitions.
<em>HashPartitioner</em> is the most common strategy for key-based operations. <em>RangePartitioner</em> is used when sorting by key
is required. Custom partitioners are also possible. Finally, a <em>partitioner</em> can be <em>None</em>,
which simply means that
partitioning strategy is not based on data characteristics; for example, it is random and uniform.</p></div>
<div class="paragraph"><p>In this example, in the first case, <em>partitioner</em> is None and in the second case, when <em>groupByKey</em>
is used, <em>partitioner</em> is <em>HashPartitioner</em>. When retrieving data from Cassandra, <em>partitioner</em> would be <em>None</em>
because partitioning is controlled by Spark-Cassandra Connector rather than Spark.</p></div>
</div>
</div>
</section>
<section class="slide" id="factors-that-affect-partitioning">
<h2>Factors That Affect Partitioning</h2>
<div class="ulist">
<ul>
<li>Resources available to an application</li>
<li>External data sources</li>
<li>Transformations used to derive an RDD</li>
<li>Partitioning properties of parent RDD(s)</li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="ulist">
<ul>
<li>Resources available to an application, such as a number of cores</li>
<li>External data sources, such as local collections, Cassandra tables, and HDFS files</li>
<li>Transformations used to derive an RDD, such as key-based transformations</li>
<li>Partitioning properties of parent RDD(s) that are used to derive an RDD</li>
</ul>
</div>
<div class="paragraph"><p>We will discuss these factors in more detail in a separate presentation.</p></div>
</div>
</div>
</section>
<section class="slide" id="partitioning-and-computation">
<h2>Partitioning and Computation</h2>
<div class="ulist">
<ul>
<li>Partition is the smallest unit of data</li>
<li>Task is the smallest unit of computation</li>
<li><em>Number of partitions</em> = <em>Number of tasks</em></li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>It is important to understand the relationship between partitioning and computation.
A separate task is scheduled to perform computation on a partition. Therefore,
in the context of one operation, the number of tasks would be equivalent to the number
of partitions.</p></div>
</div>
</div>
<div class="imageblock center">
<div class="content">
<img alt="tasks" src="images/spark/tuning-partitioning/understanding-partitioning/tasks.svg" />
</div>
</div>
</section>
<section class="slide" id="partitioning-and-default-parallelism">
<h2>Partitioning and Default Parallelism</h2>
<div class="ulist">
<ul>
<li><p>
Default level of parallelism refers to a number of tasks that can be executed concurrently<div class="ulist">
<ul>
<li>Defined as a number of cores allocated to an application in a cluster</li>
<li>General recommendation: <em>Number of partitions</em> &gt;= <em>Default Parallelism</em></li>
</ul>
</div></p></li>
</ul>
</div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:20%" />
<col style="width:80%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>defaultParallelism</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Returns a default level of parallelism of a <em>SparkContext</em> object.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph"><p><br /></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>println(sc.defaultParallelism)
// Sample output: 3

val movies = sc.parallelize(List(("Alice in Wonderland",2016), ("Alice Through the Looking Glass",2010), ...))
println(movies.partitions.size)
// Sample output: 3</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Another very important and related notion is a default level of parallelism for an application
and its <em>SparkContext</em> object. The default level of parallelism refers to a number of tasks
that can be executed concurrently and is defined as a number of cores allocated to an application in a cluster.
The default level of parallelism is customizable for each application via the <em>spark.default.parallelism</em> property.</p></div>
<div class="paragraph"><p>In this example, we have 3 cores that are available to an application. You can see that <em>parallelize</em> creates
3 partitions according to the default level of parallelism.</p></div>
</div>
</div>
</section>
<section class="slide" id="controlling-partitioning">
<h2>Controlling Partitioning</h2>
<div class="paragraph"><p><strong>One of the most important performance optimizations in Spark</strong></p></div>
<div class="ulist">
<ul>
<li>Special transformations for repartitioning datasets with desired partitioning properties</li>
<li>Many transformations support an additional parameter for a desired number of tasks</li>
<li>Certain application settings affect partitioning</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph"><p>Choosing appropriate partitioning properties based on characteristics of your data and computation may
drastically improve performance. A good solution is usually found via experimenting with different parameters.</p></div>
</td>
</tr>
</table>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>To achieve an optimal performance for your application, you will frequently need to control partitioning, including
a number of partitions to increase or decrease parallelism and a partitioner that can be reused by multiple operations.</p></div>
<div class="paragraph"><p>Spark supports special transformations for repartitioning datasets with desired partitioning properties. In addition,
many transformations support a parameter for a desired number of tasks. Certain application settings affect partitioning,
including partitions created by Spark-Cassandra Connector.</p></div>
<div class="paragraph"><p>We will discuss how and when to control partitioning in more detail in a separate presentation.</p></div>
</div>
</div>
</section>
<section class="slide" id="spark-tuning-partitioning-partitioning-rules">
<h2>Default Partitioning Behavior</h2>
<div class="paragraph"><p><strong>Scenarios we will talk about</strong></p></div>
<div class="ulist">
<ul>
<li><p>
Creating an RDD from an external data source<div class="ulist">
<ul>
<li>Local Scala collection</li>
<li>Cassandra table</li>
<li>HDFS/CFS file</li>
</ul>
</div></p></li>
<li><p>
Transforming an RDD into a new RDD<div class="ulist">
<ul>
<li>Generic transformations</li>
<li>Key-based transformations</li>
</ul>
</div></p></li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>In this presentation, we will explore rules for the <strong>default</strong> partitioning behavior.
In a separate presentation, we will talk about changing the default behavior by controlling
partitioning explicitly.</p></div>
<div class="paragraph"><p>We need to discuss two main categories of rules: external data sources and transformations.</p></div>
</div>
</div>
</section>
<section class="slide" id="parallelizing-a-scala-collection">
<h2>Parallelizing a Scala Collection</h2>
<div class="paragraph"><p><strong>Default partitioning properties</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:28%" />
<col style="width:57%" />
<col style="width:14%" />
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><strong>API Call</strong></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><strong>Resulting RDD Partitioning Properties</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions.size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitioner</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sc</em>.<em>parallelize</em>(&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sc</em>.<em>defaultParallelism</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>None</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph"><p><br /></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>println(sc.defaultParallelism)
// Sample output: 3

val movies = sc.parallelize(List(("Alice in Wonderland",2016), ("Alice Through the Looking Glass",2010), ...))
println(movies.partitions.size)
// Sample output: 3

println(movies.partitioner)
// Sample output: None</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>In this example, <em>defaultParallelism</em> equals to 3; that is how many cores in a cluster are available to our application.</p></div>
</div>
</div>
</section>
<section class="slide" id="retrieving-data-from-cassandra">
<h2>Retrieving Data From Cassandra</h2>
<div class="paragraph"><p><strong>Default partitioning properties</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:28%" />
<col style="width:57%" />
<col style="width:14%" />
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><strong>API Call</strong></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><strong>Resulting RDD Partitioning Properties</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions.size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitioner</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sc</em>.<em>cassandraTable</em>(&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sc</em>.<em>defaultParallelism</em> or
approximate-data-size / 64MBs, whichever is greater</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>None</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph"><p><br /></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>println(sc.defaultParallelism)
// Sample output: 3

val interactions = sc.cassandraTable("killr_video","video_interactions_by_user")
println(interactions.partitions.size)
// Sample output: 4

println(interactions.partitioner)
// Sample output: None</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>In this example, table <em>video_interactions_by_user</em> contains around 256MBs of data and therefore,
the number of partitions = 256/64 = 4. A smaller table would give us <em>defaultParallelism</em> = 3 partitions.</p></div>
</div>
</div>
</section>
<section class="slide" id="reading-data-from-an-hdfs-cfs-file">
<h2>Reading Data From an HDFS/CFS File</h2>
<div class="paragraph"><p><strong>Default partitioning properties</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:28%" />
<col style="width:57%" />
<col style="width:14%" />
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><strong>API Call</strong></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><strong>Resulting RDD Partitioning Properties</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions.size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitioner</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sc</em>.<em>textFile</em>(&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sc</em>.<em>defaultParallelism</em> or
a number of file blocks, whichever is greater</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>None</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph"><p><br /></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>println(sc.defaultParallelism)
// Sample output: 3

val records = sc.textFile("cfs:///tmp/videos.csv")
println(records.partitions.size)
// Sample output: 3

println(records.partitioner)
// Sample output: None</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Cassandra File System (CFS) is an implementation of HDFS.
HDFS/CFS files consist of distributed file blocks with the default size of 64MBs.</p></div>
<div class="paragraph"><p>In this example, the CSV file must be less than or equal to roughly 3 * 64MBs = 192MBs because we are getting
3 partitions in the resulting RDD.</p></div>
</div>
</div>
</section>
<section class="slide" id="generic-transformations">
<h2>Generic Transformations</h2>
<div class="paragraph"><p><strong>Default partitioning properties</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:28%" />
<col style="width:57%" />
<col style="width:14%" />
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><strong>Transformation</strong></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><strong>Resulting RDD Partitioning Properties</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions.size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitioner</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>filter</em>(&#8230;&#8203;), <em>map</em>(&#8230;&#8203;), <em>flatMap</em>(&#8230;&#8203;),
<em>distinct</em>(), &#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The same number of partitions as in the parent RDD</p></td>
<td class="tableblock halign-left valign-top" rowspan="5"><p class="tableblock"><em>None</em>, except <em>filter</em> preserves parent RDD&#8217;s <em>partitioner</em>, if any</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>union</em>(<em>otherRDD</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>partitions</em>.<em>size</em> + <em>otherRDD</em>.<em>partitions</em>.<em>size</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>intersection</em>(<em>otherRDD</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>max</em>(<em>rdd</em>.<em>partitions</em>.<em>size</em>, <em>otherRDD</em>.<em>partitions</em>.<em>size</em>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>subtract</em>(<em>otherRDD</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>partitions</em>.<em>size</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>cartesian</em>(<em>otherRDD</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>partitions</em>.<em>size</em> * <em>otherRDD</em>.<em>partitions</em>.<em>size</em></p></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Unary transformations result in the same number of partitions as in the source RDD.</p></div>
<div class="paragraph"><p>For binary transformations, the resulting number of partitions is different for each transformation.</p></div>
<div class="paragraph"><p>All these transformations result in <em>None</em> for <em>partitioner</em>,exept <em>filter</em> can preserve parent RDD&#8217;s
<em>partitioner</em>.</p></div>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>Example</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>val movies = sc.cassandraTable("killr_video","movies")
// Partitioning properties: 3, None

val favoriteMovies = sc.cassandraTable("killr_video","favorite_movies")
// Partitioning properties: 3, None

val allMovies = movies.union(favoriteMovies)
// Partitioning properties: 6, None</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>3 + 3 = 6</p></div>
</div>
</div>
</section>
<section class="slide" id="key-based-transformations">
<h2>Key-Based Transformations</h2>
<div class="paragraph"><p><strong>Default partitioning properties</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:28%" />
<col style="width:57%" />
<col style="width:14%" />
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><strong>Transformation</strong></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><strong>Resulting RDD Partitioning Properties</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitions.size</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitioner</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>reduceByKey</em>(&#8230;&#8203;), <em>foldByKey</em>(&#8230;&#8203;),
<em>combineByKey</em>(&#8230;&#8203;), <em>groupByKey</em>(), &#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top" rowspan="3"><p class="tableblock">The same number of partitions as in the parent RDD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>HashPartitioner</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sortByKey</em>(&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>RangePartitioner</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>mapValues</em>(&#8230;&#8203;), <em>flatMapValues</em>(&#8230;&#8203;)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parent RDD&#8217;s <em>partitioner</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>cogroup</em>(&#8230;&#8203;), <em>join</em>(&#8230;&#8203;), <em>leftOuterJoin</em>(&#8230;&#8203;), <em>rightOuterJoin</em>(&#8230;&#8203;), &#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The same number of partitions as in the source RDD or the other RDD, depending on partitioning properties of the inputs.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>HashPartitioner</em></p></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Unary transformations may result in different partitioners but the number of partitions is always the same
as in parent RDDs.</p></div>
<div class="paragraph"><p>For binary transformations, the number of partitions is determined by both the <em>partitioner</em> and <em>partitions.size</em>
properties of the input RDDs. We will discuss this rule in more detail soon.</p></div>
<div class="paragraph"><p>It is very important to understand that any transformation that sets a partitioner (whether <em>HashPartitioner</em>,
<em>RangePartitioner</em>, or custom partitioner) requires data shuffling. Data is reorganized into new partitions
using the partitioner. This requires disk I/O. In other words, such transformations are more expensive.
Whenever possible, partitioning from a previous operation should be reused to avoid shuffling. Spark can and will
reuse partitioning when possible but a developer should be careful not to break partitioning in her code.</p></div>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>Example - unary transformations</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>val moviesByYear = sc.cassandraTable("killr_video","movies")
                     .keyBy(row =&gt; row.getInt("release_year"))
                     .groupByKey
// Partitioning properties: HashPartitioner@3

val moviesByYear2010 = moviesByYear.filter{case (y,rows) =&gt; y == 2010}
// Partitioning properties: HashPartitioner@3

val movies2010 = moviesByYear2010.flatMapValues(rows =&gt; rows)
// Partitioning properties: HashPartitioner@3

val capitalizedMovies2010 = movies2010.map{case (y,row) =&gt; (y,row.getString("title").capitalize)}
// Partitioning properties: 3, None</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Both <em>cassandraTable</em> and <em>keyBy</em> result in 3, <em>None</em>.</p></div>
<div class="paragraph"><p><em>groupByKey</em> sets the <em>partitioner</em> to <em>HashPartitioner</em> with 3 partitions.</p></div>
<div class="paragraph"><p><em>filter</em> and <em>flatMapValues</em> preserve partitioning properties.</p></div>
<div class="paragraph"><p><em>map</em> causes <em>partitioner</em> to become <em>None</em>, even though the transformation does not affect keys in this example.
Spark does not analyze our anonymous function code; it simply assumes that our code may have changed keys and therefore,
key-based hash partitioning is now broken. To avoid this situation, we should have used <em>mapValues</em> instead of <em>map</em>.</p></div>
</div>
</div>
</section>
<section class="slide" id="binary-key-based-transformations">
<h2>Binary Key-Based Transformations</h2>
<div class="paragraph"><p><strong>Default number of partitions</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:16%" />
<col style="width:16%" />
<col style="width:16%" />
<col style="width:50%" />
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><strong>rdd.join(otherRDD)</strong>, <strong>rdd.cogroup(otherRDD)</strong>, &#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><strong>Partionner Can Be Reused</strong></p></td>
<td class="tableblock halign-left valign-top" rowspan="2"><p class="tableblock"><strong>Resulting RDD partitions.size</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>rdd</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>otherRDD</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>max</em>(<em>rdd</em>.<em>partitions</em>.<em>size</em>, <em>otherRDD</em>.<em>partitions</em>.<em>size</em>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>rdd</em>.<em>partitions</em>.<em>size</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case 3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>otherRDD</em>.<em>partitions</em>.<em>size</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case 4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>max</em>(<em>rdd</em>.<em>partitions</em>.<em>size</em>, <em>otherRDD</em>.<em>partitions</em>.<em>size</em>)</p></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Here are the four scenarios to determine how Spark derives a number of partitions in the resulting RDD
when a binary key-based transformation is used.</p></div>
<div class="paragraph"><p>When one or both inputs have suitable partitioners to perform a transformation, Spark reuses
partitions without shuffling for better efficiency.</p></div>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>Example - binary transformations</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>val users = sc.cassandraTable("killr_video","users")
              .keyBy(row =&gt; row.getInt("user_id"))
// Partitioning properties: 3, None

val interactions = sc.cassandraTable("killr_video","video_interactions_by_user")
                     .keyBy(row =&gt; row.getInt("user_id"))
                     .groupByKey
// Partitioning properties: HashPartitioner@4

val usersWithInteractions = users.join(interactions)
// Partitioning properties: HashPartitioner@4</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>This is an example of Case 3: <em>interactions</em>' partitioner and number of partitions are reused to compute the join with <em>users</em>.</p></div>
</div>
</div>
</section>
<section class="slide" id="spark-tuning-partitioning-controlling-partitioning">
<h2>Controlling Partitioning</h2>
<div class="paragraph"><p><strong>One of the most important performance optimizations in Spark</strong></p></div>
<div class="ulist">
<ul>
<li><p>
Number of partitions<div class="ulist">
<ul>
<li>Affects a number of tasks and the level of parallelism</li>
<li><em>Goal</em>: balancing task execution and scheduling times</li>
</ul>
</div></p></li>
<li><p>
Partitioner<div class="ulist">
<ul>
<li>Affects key-based operations</li>
<li><em>Goal</em>: Avoiding shuffling the same dataset multiple times</li>
</ul>
</div></p></li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Optimal partitioning results in optimal performance.</p></div>
<div class="paragraph"><p>By controlling a number of partitions in an RDD, we affect a number
of tasks that execute our operations and, ultimately, the level of parallelism for
each operation. If a task is running for too long and fails, re-executing the task will still
take long time. If tasks are running for a few milliseconds, then it is likely that scheduling time
will have a considerable impact on overall performance of an application. Finding a balance between
task execution and scheduling times is the first main reason to pay attention to partitioning.</p></div>
<div class="paragraph"><p>By controlling a partitioner for an RDD, we affect key-based operations that rely on specific partitioners,
such as <em>HashPartitioner</em> or <em>RangePartitioner</em>, to perform computation. Setting a partitioner for an RDD
triggers the process called shuffling, which is expensive because data has to be reorganized into
new partitions, and that requires disk I/O and network traffic. Pre-partitioning and caching an RDD in certain situations
can avoid re-shuffling the same RDD multiple times, which is the second main reason to control partitioning.</p></div>
</div>
</div>
</section>
<section class="slide" id="how-many-partitions-is-good">
<h2>How Many Partitions is Good?</h2>
<div class="paragraph"><p><strong>General insights</strong></p></div>
<div class="ulist">
<ul>
<li><p>
Too few partitions can be a problem<div class="ulist">
<ul>
<li>Less concurrency</li>
<li>Possible data skew</li>
<li>Increased memory pressure</li>
<li>Longer recovery from a failure</li>
</ul>
</div></p></li>
<li><p>
Too many partitions can be a problem<div class="ulist">
<ul>
<li>Task scheduling may take longer than task execution</li>
<li>More lineage information to maintain</li>
</ul>
</div></p></li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>These are some general insights on a number of partitions.</p></div>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>General recommendations</strong></p></div>
<div class="ulist">
<ul>
<li>Usually between 100 and 10,000 partitions depending on data and cluster size</li>
<li>Lower bound – 2x number of cores in a cluster available to an application</li>
<li>Upper bound – tasks should take 100+ ms to execute</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph"><p>You will often need to change the default number of partitions to
optimize your application performance! The best results are frequently achieved by
experimenting with different partitioning settings and monitoring the metrics in
<em>Spark Application Web UI</em>.</p></div>
</td>
</tr>
</table>
</div>
<div class="imageblock center">
<div class="content">
<img alt="screenshot ui" src="images/spark/tuning-partitioning/controlling-partitioning/screenshot-ui.svg" />
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Remember that, by default, the default level of parallelism (<em>sc.defaultParallelism</em>) equals
to a number of cores available to an application, which implies the number of partitions for
<em>parallelize</em>, <em>textFile</em>, <em>cassandraTable</em>, and many Spark operations.</p></div>
<div class="paragraph"><p>You can always get metrics for scheduling and execution times from the Spark Application UI.</p></div>
</div>
</div>
</section>
<section class="slide" id="which-operations-do-require-a-partitioner">
<h2>Which Operations Do Require a Partitioner?</h2>
<div class="paragraph"><p><strong>Many key-based operations</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:20%" />
<col style="width:80%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Partitioner</th>
<th class="tableblock halign-left valign-top">Operations</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>HashPartitioner</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>reduceByKey</em>, <em>foldByKey</em>, <em>combineByKey</em>,
   <em>groupByKey</em>, <em>cogroup</em>,
   <em>join</em>, <em>leftOuterJoin</em>, <em>rightOuterJoin</em>, <em>fullOuterJoin</em>, <em>lookup</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>RangePartitioner</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sortByKey</em></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph"><p>Spark allows defining custom partitioners, which may be useful when you have special requirements
for assigning a key to a partition.</p></div>
</td>
</tr>
</table>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Most key-based operations (transformations and actions) require a key-based partitioner.
If an input RDD has <em>None</em> as a partitioner, Spark will shuffle data and set a partitioner while performing an operation.
If an input RDD has a key-based partitioner, Spark will reuse it without shuffling to perform an operation.
We need to focus on reusing a partitioner whenever possible!</p></div>
</div>
</div>
</section>
<section class="slide" id="setting-and-reusing-a-partitioner">
<h2>Setting and Reusing a Partitioner</h2>
<div class="paragraph"><p><strong>Sample optimization scenario</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:40%" />
<col style="width:60%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Suboptimal case</th>
<th class="tableblock halign-left valign-top">Optimal case</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="imageblock center">
<div class="content">
<img alt="suboptimal case" src="images/spark/tuning-partitioning/controlling-partitioning/suboptimal-case.svg" />
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="imageblock center">
<div class="content">
<img alt="optimal case" src="images/spark/tuning-partitioning/controlling-partitioning/optimal-case.svg" />
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Here is a sample optimization scenario that demonstrates how to avoid re-shuffling the same RDD.
We use DAGs of operations to illustrate the concepts.</p></div>
<div class="paragraph"><p>In the suboptimal case, we perform two key-based transformations on <em>rdd1</em> with no partitioner to derive <em>rdd2</em> and <em>rdd3</em> and
one key-based action. Let us assume all the three operations require a <em>HashPartitioner</em>. There are two
more actions on <em>rdd2</em> and <em>rdd3</em>, which may or may not be key-based. Given the lazy evaluation
used in Spark and the three actions, we will have to perform shuffling of <em>rdd1</em> three times
(even if <em>rdd1</em> is cached in-memory)
to satisfy key-based partitioning requirements. That is not efficient.</p></div>
<div class="paragraph"><p>In the optimal case, we first explicitly pre-partition and cache <em>rdd1</em> using special transformations
and <em>HashPartitioner</em> into <em>rdd1'</em>. This enables the key-based transformations and action to reuse
the <em>rdd1'</em> partitioner rather then shuffle. As a result, Spark can avoid two extra shuffling operations.</p></div>
<div class="paragraph"><p>As you may have noticed, use cases for the setting a partitioner and caching optimizations have some common ground.
With respect to a DAG of operations, any RDD that has multiple descendants is a good candidate for caching.
It is also a good candidate for explicitly setting a key-based partitioner if its descendants can
reuse the partitioner. Therefore, setting a partitioner is always followed by caching.</p></div>
</div>
</div>
</section>
<section class="slide" id="mechanisms-for-controlling-partitioning">
<h2>Mechanisms for Controlling Partitioning</h2>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:25%" />
<col style="width:75%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mechanism</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Application settings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Special properties, such as <em>spark.default.parallelism</em> and <em>spark.cassandra.input.split.size_in_mb</em>,
that can affect a number of partitions for Spark and Cassandra RDDs when set on the <em>SparkConf</em> object to initialize an application <em>SparkContext</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operation parameters</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Many API calls, transformations, and actions can take an additional parameter to specify a number of tasks to use to
compute the result, which directly affects a number of partitions. For example, <em>parallelize</em>(&#8230;&#8203;,<em>numTasks</em>),
<em>textFile</em>(&#8230;&#8203;,<em>numTasks</em>), <em>reduceByKey</em>(&#8230;&#8203;,<em>numTasks</em>), <em>groupByKey</em>(<em>numTasks</em>), <em>join</em>(&#8230;&#8203;,<em>numTasks</em>),
<em>countByKey</em>(<em>numTasks</em>), etc.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Repartitioning transformations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>repartition</em>, <em>coalesce</em>,
 <em>partitionBy</em></p></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>The first two mechanisms should be straightforward.
They only allow controlling a number of partitions (level of parallelism).</p></div>
<div class="paragraph"><p>For the rest of this presentation, we will focus on the last mechanism&#8201;&#8212;&#8201;the three repartitioning transformations.</p></div>
</div>
</div>
</section>
<section class="slide" id="transformations-em-repartition-em-and-em-coalesce-em">
<h2>Transformations <em>repartition</em> and <em>coalesce</em></h2>
<div class="paragraph"><p><strong>Repartitioning transformations for generic RDDs</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:20%" />
<col style="width:80%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Transformation</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>repartition</strong>(<em>numPartitions</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A new RDD is formed by shuffling elements of the source RDD into <em>numPartitions</em> new partitions,
where <em>numPartitions</em> can be larger or smaller than the number of partitions in the source RDD. The new
RDD partitioner is set to <em>None</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>coalesce</strong>(<em>numPartitions</em>, [<em>shuffle</em>])</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A new RDD is formed by merging partitions of the source RDD into <em>numPartitions</em> new partitions,
where <em>numPartitions</em> must be smaller than the number of partitions in the source RDD. The optional
parameter disables shuffling by default (<em>shuffle = false</em>). With shuffling enabled, <em>coalesce</em> can be used
like <em>repartition</em> to decrease or increase a number of partitions. The new
RDD partitioner is set to <em>None</em>.</p></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>These transformations always result in <em>None</em> as a partitioner, even if a parent RDD has a key-based partitioner.
Therefore, they are commonly used with generic rather than key-value pair RDDs.</p></div>
</div>
</div>
<div style="page-break-after: always"></div>
<div class="paragraph"><p><strong>Example</strong></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>println(sc.defaultParallelism)
// Sample output: 3

val movies = sc.parallelize(List(("Alice in Wonderland",2016), ("Alice Through the Looking Glass",2010), ...))
println(movies.partitions.size)
// Sample output: 3

println(movies.repartition(2*sc.defaultParallelism).partitions.size)
// Sample output: 6

println(movies.coalesce(4).partitions.size)
// Sample output: 4</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>In this example, <em>repartition</em> will shuffle but <em>coalesce</em> will not.</p></div>
</div>
</div>
</section>
<section class="slide" id="transformation-em-partitionby-em">
<h2>Transformation <em>partitionBy</em></h2>
<div class="paragraph"><p><strong>Repartitioning transformation for key-value pair RDDs</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:20%" />
<col style="width:80%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Transformation</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>partitionBy</strong>(<em>Partitioner</em>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A new RDD is formed by shuffling elements of the source RDD  into <em>numPartitions</em> new partitions
using a specified <em>Partitioner</em>, which
can be <em>HashPartitioner</em>(<em>numPartitions</em>), <em>RangePartitioner</em>(<em>numPartitions</em>, <em>sourceRDD</em>), or
a custom partitioner.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph"><p><br /></p></div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code>val movies = sc.parallelize(List(("Alice in Wonderland",2016), ("Alice Through the Looking Glass",2010), ...))
               .partitionBy(new org.apache.spark.HashPartitioner(9))

println(movies.partitioner)
// Sample output: HashPartitioner@9</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>The <em>partitionBy</em> transformation results in an RDD with a desired partitioner.
Therefore, it is commonly used with key-value pair RDDs.</p></div>
</div>
</div>
</section>
<section class="slide" id="challenge">
<h2>Challenge</h2>
<div class="paragraph"><p><strong>Suboptimal code</strong></p></div>
<div class="imageblock right" style="float: right">
<div class="content">
<img alt="movies" src="images/spark/tuning-partitioning/controlling-partitioning/movies.svg" />
</div>
</div>
<div class="listingblock left">
<div class="content">
<pre class="CodeRay"><code>val movies = sc.cassandraTable("killr_video","movies")
               .keyBy(row =&gt; row.getInt("release_year"))
               .repartition(2*sc.defaultParallelism)

val movieCountByYear  = movies.countByKey.foreach(println)

val moviesByYear = movies.groupByKey.collect.foreach(println)</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Shuffling is done three times in this example.</p></div>
</div>
</div>
</section>
<section class="slide" id="challenge-solution">
<h2>Challenge Solution</h2>
<div class="paragraph"><p><strong>Optimized code</strong></p></div>
<div class="imageblock right" style="float: right">
<div class="content">
<img alt="movies" src="images/spark/tuning-partitioning/controlling-partitioning/movies.svg" />
</div>
</div>
<div class="listingblock left">
<div class="content">
<pre class="CodeRay"><code>val movies = sc.cassandraTable("killr_video","movies")
               .keyBy(row =&gt; row.getInt("release_year"))
               .partitionBy(
                 new org.apache.spark.HashPartitioner(2*sc.defaultParallelism))
               .cache

val movieCountByYear  = movies.countByKey.foreach(println)

val moviesByYear = movies.groupByKey.collect.foreach(println)</code></pre>
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Shuffling is only done once in this example.</p></div>
</div>
</div>
</section>
<section class="slide" id="spark-tuning-partitioning-data-shuffling">
<h2>Data Shuffling</h2>
<div class="paragraph"><p><strong>Definition and use cases</strong></p></div>
<div class="paragraph"><p><em><strong>Definition</strong></em></p></div>
<div class="verseblock">
<pre class="content">Data shuffling is the process of reorganizing and transferring data from existing partitions
into new partitions to achieve one or both properties for the resulting partitions:
1) having a desired number of partitions
2) having pairs with the same key in the same partition</pre>
</div>
<div class="paragraph"><p><br /></p></div>
<div class="paragraph"><p><em><strong>Main use cases</strong></em></p></div>
<div class="ulist">
<ul>
<li>Controlling the level of parallelism</li>
<li>Supporting some key-based operations</li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Understanding data shuffling helps to write efficient code.</p></div>
</div>
</div>
</section>
<section class="slide" id="which-operations-may-trigger-shuffling">
<h2>Which Operations May Trigger Shuffling?</h2>
<div class="ulist">
<ul>
<li><p>
Repartitioning transformations<div class="ulist">
<ul>
<li><em>repartition</em>, <em>coalesce</em>, <em>partitionBy</em></li>
</ul>
</div></p></li>
<li><p>
Many key-based operations<div class="ulist">
<ul>
<li><em>reduceByKey</em>, <em>foldByKey</em>, <em>combineByKey</em></li>
<li><em>groupByKey</em>, <em>cogroup</em></li>
<li><em>join</em>, <em>leftOuterJoin</em>, <em>rightOuterJoin</em>, <em>fullOuterJoin</em></li>
<li><em>sortByKey</em></li>
<li><em>lookup</em></li>
</ul>
</div></p></li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>These are some exceptions:</p></div>
<div class="ulist">
<ul>
<li><em>coalesce</em> may or may not require shuffling depending on its <em>shuffle</em> parameter</li>
<li>Key-based operations will not shuffle data if an RDD has an appropriate partitioner (in other words,
the RDD has been shuffled in a previous transformation)</li>
</ul>
</div>
</div>
</div>
</section>
<section class="slide" id="how-does-shuffling-work">
<h2>How Does Shuffling Work?</h2>
<div class="paragraph"><p><strong>Shuffling an RDD with three partitions into an RDD with four partitions</strong></p></div>
<div class="imageblock center">
<div class="content">
<img alt="shuffling" src="images/spark/tuning-partitioning/data-shuffling/shuffling.svg" />
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Let us consider how shuffling is done in general. This illustration shows
how an RDD with three partitions is shuffled into an RDD with four partitions.</p></div>
<div class="ulist">
<ul>
<li>Shuffle write: A <em>Map Task</em> is executed on each original partition. It repartitions data into four new buckets that
are written to disk on a worker node. Partial aggregation may be used for some operations (e.g., <em>reduceByKey</em>),
to aggregate pairs with the same key in the buckets before writing them to disk.</li>
<li>Shuffle read: Four <em>Reduce Tasks</em> read their corresponding on-disk buckets into memory to assemble new partitions:
A, B, C, and D. Final aggregation is again only required for certain operations. The new RDD now has four partitions
that can be processed by further operations.</li>
</ul>
</div>
<div class="paragraph"><p>How buckets are computed depends on an operation and its partitioner (<em>None</em>, <em>HashPartitioner</em>, <em>RangePartitioner</em>, custom partitioner).</p></div>
</div>
</div>
</section>
<section class="slide" id="types-of-shuffling">
<h2>Types of Shuffling</h2>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:50%" />
<col style="width:50%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Sort-based shuffling</th>
<th class="tableblock halign-left valign-top">Hash-based shuffling</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>Generally more efficient</li>
<li>Default strategy in Spark 1.2+</li>
<li>Writes <em>2 x M</em> files</li>
</ul>
</div>
<div class="imageblock center">
<div class="content">
<img alt="two files" src="images/spark/tuning-partitioning/data-shuffling/two-files.svg" />
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="ulist">
<ul>
<li>Generally less efficient</li>
<li>Default strategy prior Spark 1.2</li>
<li>Writes <em>M x R</em> files</li>
</ul>
</div>
<div class="imageblock center">
<div class="content">
<img alt="many files" src="images/spark/tuning-partitioning/data-shuffling/many-files.svg" />
</div>
</div></div></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Sort-based shuffling is generally more efficient for big data use cases.</p></div>
<div class="paragraph"><p><em>M</em> denotes a number of map tasks.
<em>R</em> denotes a number of reduce tasks.</p></div>
<div class="paragraph"><p>The illustrations are for a single map task.</p></div>
</div>
</div>
</section>
<section class="slide" id="shuffling-is-expensive">
<h2>Shuffling is Expensive</h2>
<div class="paragraph"><p><strong>Shuffling cost factors</strong></p></div>
<div class="ulist">
<ul>
<li>Disk IO</li>
<li>Network traffic</li>
<li>Partitioning</li>
<li>External sorting</li>
<li>Serialization/deserialization</li>
<li>Data compression</li>
</ul>
</div>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Some of these factors may be eliminated or partially eliminated, depending
on application settings and shuffling algorithms used. However Disk IO and
network traffic are guaranteed!</p></div>
</div>
</div>
</section>
<section class="slide" id="how-to-optimize-shuffling-performance">
<h2>How to Optimize Shuffling Performance?</h2>
<div class="ulist">
<ul>
<li>Control partitioning to avoid re-shuffling</li>
<li>Take advantage of aggregation when possible</li>
<li>Choose appropriate application properties</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
<em>Spark Application Web UI</em> provides information about your application shuffle writes and reads.
</td>
</tr>
</table>
</div>
<div class="imageblock center">
<div class="content">
<img alt="screenshot ui" src="images/spark/tuning-partitioning/data-shuffling/screenshot-ui.svg" />
</div>
</div>
<div class="openblock notes">
<div class="content">
<div class="ulist">
<ul>
<li>Control partitioning to avoid re-shuffling&#8201;&#8212;&#8201;discussed in a separate vertex</li>
<li>Take advantage of aggregation when possible&#8201;&#8212;&#8201;prefer <em>reduceByKey</em> to <em>groupByKey</em> when doing aggregation</li>
<li>Choose appropriate application properties&#8201;&#8212;&#8201;next slide</li>
</ul>
</div>
<div class="paragraph"><p>The screenshot shows shuffle write and shuffle read in the last two columns.</p></div>
</div>
</div>
</section>
<section class="slide" id="application-shuffling-properties">
<h2>Application Shuffling Properties</h2>
<div class="paragraph"><p><strong>Configurable on a <em>SparkConf</em> object</strong></p></div>
<table class="tableblock frame-all grid-all" style="width:100%">
<colgroup>
<col style="width:28%" />
<col style="width:57%" />
<col style="width:14%" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spark.shuffle.manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a data shuffling strategy to be <em>sort</em> or <em>hash</em>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sort</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spark.shuffle.spill</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables or disables spilling data out to disk by reduce tasks.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>true</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spark.shuffle.memoryFraction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies a spilling threshold as a fraction of Java heap.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>0.2</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spark.shuffle.sort.bypassMergeThreshold</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instructs sort-based shuffling to not  merge-sort data
if there is no map-side aggregation and a number of reduce tasks is not greater than
this threshold.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>200</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spark.shuffle.compress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables or disable compression for shuffle writes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>true</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spark.shuffle.spill.compress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables or disable compression for data spilled out to disk.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>true</em></p></td>
</tr>
</tbody>
</table>
<div class="openblock notes">
<div class="content">
<div class="paragraph"><p>Some of the common application shuffling properties. Default values are generally good.</p></div>
<div class="paragraph"><p>This is not a comprehensive list of shuffling properties.</p></div>
</div>
</div>
</section>
<div aria-role="navigation">
<a class="deck-prev-link" href="#" title="Previous">
<i class="icon-chevron-with-circle-left"></i>
</a>
<a class="deck-next-link" href="#" title="Next">
<i class="icon-chevron-with-circle-right"></i>
</a>
</div>
</div>
<script src="deck.js/jquery.min.js"></script>
<script src="deck.js/d3.v2.js"></script>
<script src="deck.js/jquery-ui.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/split/deck.split.js"></script>
<script src="deck.js/extensions/animation/deck.animation.js"></script>
<script src="deck.js/extensions/deck.js-notes/deck.notes.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/clone/deck.clone.js"></script>
<script src="deck.js/extensions/svg/svg.min.js"></script>
<script src="js/course.js"></script>
<footer>
<div class="flex-element deck-course">
<p>&copy; 2016 DataStax. Use only with permission. &bull;
<span class="course-title">Tuning and Partitioning</span></p>
</div>
<div class="flex-element deck-brand">
<a href="http://academy.datastax.com" target="blank">DataStax Academy</a>
</div>
<div class="deck-progressbar">
<span></span>
</div>
</footer>
<script type="text/javascript">
  //<![CDATA[
    (function($, deck, undefined) {
      $.deck.defaults.keys['previous'] = [8, 33, 37, 39];
      $.deck.defaults.keys['next'] = [13, 32, 34, 39];
    
      $.extend(true, $[deck].defaults, {
          countNested: false
      });
    
      $.deck('.slide');
      $.deck('disableScale');
    })(jQuery, 'deck');
  //]]>
</script>
<script type="text/javascript">
  //<![CDATA[
    $(document).bind('deck.change', function(event, from, to) {
      var width = to / ($.deck('getSlides').length - 1) * 100;
      $('.deck-progressbar span').css('width', width + '%');
    });
  //]]>
</script>
</body>
</html>